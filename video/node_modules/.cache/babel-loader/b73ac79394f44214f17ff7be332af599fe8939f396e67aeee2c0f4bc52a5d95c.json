{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\msado\\\\OneDrive\\\\Pulpit\\\\video-stream\\\\video\\\\src\\\\components\\\\VideoPlayer.jsx\",\n  _s = $RefreshSig$();\n// Random ints working///////////////////////////////////\n// import React, { useState, useEffect } from 'react';\n\n// const VideoBlob = () => {\n//   const [currentData, setCurrentData] = useState([]);\n\n//   useEffect(() => {\n//     const ws = new WebSocket(\"ws://localhost:8888/\");\n\n//     ws.onopen = () => {\n//       console.log('Opened Connection!');\n//     };\n\n//     ws.onmessage = (event) => {\n//       setCurrentData(JSON.parse(event.data));\n//     };\n\n//     ws.onclose = () => {\n//       console.log('Closed Connection!');\n//     };\n\n//     return () => {\n//       ws.close();\n//     };\n//   }, []);\n\n//   console.log(currentData);\n\n//   return (\n//     <div>\n//       {currentData.map((cd)=>(\n//         <div>\n//           <p>{cd.name}</p>\n//           <p>{cd.number}</p>\n//         </div>\n//       ))}\n//     </div>\n//   );\n// };\n\n// export default VideoBlob;\n\n// PING_PONG////////////////////////////////////////////////\n// import React, { useEffect, useRef } from 'react';\n\n// function VideoBlob() {\n//   const socketRef = useRef(null);\n\n//   useEffect(() => {\n//     // Create a WebSocket connection\n//     socketRef.current = new WebSocket('ws://localhost:8000');\n\n//     // Listen for messages from the server\n//     socketRef.current.onmessage = function (event) {\n//       console.log('Received: ', event.data);\n//     };\n\n//     // Clean up the WebSocket connection when the component is unmounted\n//     return () => {\n//       socketRef.current.close();\n//     };\n//   }, []);\n\n//   const sendPing = () => {\n//     if (socketRef.current.readyState === WebSocket.OPEN) {\n//       // Send a ping message to the server\n//       socketRef.current.send('ping');\n//     }\n//   };\n\n//   return (\n//     <div className=\"App\">\n//       <button onClick={sendPing}>Send Ping</button>\n//     </div>\n//   );\n// }\n\n// export default VideoBlob;\n\n// App.js chunks are coming frm server but problem is here\n// import React, { useEffect, useRef } from \"react\";\n\n// function VideoBlob() {\n//   const videoRef = useRef(null);\n//   const wsRef = useRef(null);\n//   const receivedChunks = useRef([]);\n//   const totalBytesReceived = useRef(0);\n\n//   useEffect(() => {\n//     wsRef.current = new WebSocket(\"ws://localhost:8000\");\n\n//     wsRef.current.onmessage = (event) => {\n//       const videoChunk = event.data;\n//       receivedChunks.current.push(videoChunk);\n//       totalBytesReceived.current += videoChunk.length;\n\n//       // Check if all chunks are received (e.g., by comparing total received bytes with expected size)\n//       // If all chunks are received, proceed to create and play the video\n\n//         const concatenatedChunks = new Uint8Array(totalBytesReceived.current);\n//         let offset = 0;\n//         for (const chunk of receivedChunks.current) {\n//           concatenatedChunks.set(chunk, offset);\n//           offset += chunk.length;\n//         }\n\n//         // Create a Blob from the concatenated chunks\n//         const videoBlob = new Blob([concatenatedChunks], { type: \"video/mp4\" });\n\n//         // Create a Blob URL\n//         const videoUrl = URL.createObjectURL(videoBlob);\n\n//         // Set the video element's src attribute to the Blob URL\n//         videoRef.current.src = videoUrl;\n\n//     };\n\n//     return () => {\n//       wsRef.current.close();\n//     };\n//   }, []);\n\n//   return (\n//     <div>\n//       <video ref={videoRef} controls />\n//     </div>\n//   );\n// }\n\n// export default VideoBlob;\n\n// //////////////////dane przychodza ale nie odtwarza video\nimport React, { useEffect, useRef } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction VideoPlayer() {\n  _s();\n  const videoRef = useRef(null);\n  const wsRef = useRef(null);\n  const mediaSourceRef = useRef(null);\n  const sourceBufferRef = useRef(null);\n  const bufferQueueRef = useRef([]);\n  const isAppendingRef = useRef(false);\n  const isSourceOpenRef = useRef(false);\n  useEffect(() => {\n    wsRef.current = new WebSocket(\"ws://localhost:8000\");\n    wsRef.current.onmessage = event => {\n      console.log(event);\n      if (typeof event.data === \"string\") {\n        console.log(\"string\");\n        const message = JSON.parse(event.data);\n        if (message.type === \"metadata\") {\n          console.log(\"metadata\");\n          const mediaSource = new MediaSource();\n          videoRef.current.src = URL.createObjectURL(mediaSource);\n          mediaSourceRef.current = mediaSource;\n          mediaSource.addEventListener(\"sourceopen\", handleSourceOpen);\n          mediaSource.addEventListener(\"sourceended\", handleSourceEnded);\n          mediaSource.addEventListener(\"error\", handleSourceError);\n        }\n      } else if (event.data instanceof Blob && sourceBufferRef.current) {\n        console.log(\"third\");\n        const videoData = event.data;\n        bufferQueueRef.current.push(videoData);\n        processBufferQueue();\n      }\n    };\n    return () => {\n      wsRef.current.close();\n    };\n  }, []);\n  const handleSourceOpen = () => {\n    const mediaSource = mediaSourceRef.current;\n    const sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"');\n    sourceBufferRef.current = sourceBuffer;\n    isSourceOpenRef.current = true;\n    sourceBuffer.addEventListener(\"updateend\", processBufferQueue);\n  };\n  const handleSourceEnded = () => {\n    console.log(\"MediaSource ended\");\n  };\n  const handleSourceError = error => {\n    console.error(\"MediaSource error:\", error);\n  };\n  const processBufferQueue = async () => {\n    if (isSourceOpenRef.current && !isAppendingRef.current && bufferQueueRef.current.length > 0) {\n      const videoData = bufferQueueRef.current.shift();\n      isAppendingRef.current = true;\n      try {\n        const response = await fetch(URL.createObjectURL(videoData));\n        const arrayBuffer = await response.arrayBuffer();\n        sourceBufferRef.current.appendBuffer(arrayBuffer);\n      } catch (error) {\n        console.error(\"Error appending video data to SourceBuffer:\", error);\n        isAppendingRef.current = false;\n        processBufferQueue();\n      }\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      controls: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 217,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 216,\n    columnNumber: 5\n  }, this);\n}\n_s(VideoPlayer, \"ontn290HU37LpcHXNXa7biQxN5E=\");\n_c = VideoPlayer;\nexport default VideoPlayer;\n\n// /////////////17.07\n// import React, { useEffect, useRef } from \"react\";\n\n// const VideoPlayer = () => {\n//   const videoRef = useRef(null);\n//   const websocketRef = useRef(null);\n\n//   useEffect(() => {\n//     // Create a WebSocket connection\n//     const socket = new WebSocket(\"ws://localhost:8000\");\n\n//     socket.onopen = () => {\n//       console.log(\"Connected to server\");\n//     };\n\n//     socket.onmessage = (event) => {\n//       // Receive video data from the server\n//       const data = event.data;\n//       videoRef.current.src = URL.createObjectURL(data);\n//     };\n\n//     socket.onclose = () => {\n//       console.log(\"Disconnected from server\");\n//     };\n\n//     websocketRef.current = socket;\n\n//     return () => {\n//       // Clean up the WebSocket connection\n//       websocketRef.current.close();\n//     };\n//   }, []);\n\n//   return (\n//     <div>\n//       <video ref={videoRef} controls autoPlay />\n//     </div>\n//   );\n// };\n\n// export default VideoPlayer;\nvar _c;\n$RefreshReg$(_c, \"VideoPlayer\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","VideoPlayer","_s","videoRef","wsRef","mediaSourceRef","sourceBufferRef","bufferQueueRef","isAppendingRef","isSourceOpenRef","current","WebSocket","onmessage","event","console","log","data","message","JSON","parse","type","mediaSource","MediaSource","src","URL","createObjectURL","addEventListener","handleSourceOpen","handleSourceEnded","handleSourceError","Blob","videoData","push","processBufferQueue","close","sourceBuffer","addSourceBuffer","error","length","shift","response","fetch","arrayBuffer","appendBuffer","children","ref","controls","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/msado/OneDrive/Pulpit/video-stream/video/src/components/VideoPlayer.jsx"],"sourcesContent":["// Random ints working///////////////////////////////////\r\n// import React, { useState, useEffect } from 'react';\r\n\r\n// const VideoBlob = () => {\r\n//   const [currentData, setCurrentData] = useState([]);\r\n\r\n//   useEffect(() => {\r\n//     const ws = new WebSocket(\"ws://localhost:8888/\");\r\n\r\n//     ws.onopen = () => {\r\n//       console.log('Opened Connection!');\r\n//     };\r\n\r\n//     ws.onmessage = (event) => {\r\n//       setCurrentData(JSON.parse(event.data));\r\n//     };\r\n\r\n//     ws.onclose = () => {\r\n//       console.log('Closed Connection!');\r\n//     };\r\n\r\n//     return () => {\r\n//       ws.close();\r\n//     };\r\n//   }, []);\r\n\r\n\r\n\r\n//   console.log(currentData);\r\n\r\n//   return (\r\n//     <div>\r\n//       {currentData.map((cd)=>(\r\n//         <div>\r\n//           <p>{cd.name}</p>\r\n//           <p>{cd.number}</p>\r\n//         </div>\r\n//       ))}\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default VideoBlob;\r\n\r\n// PING_PONG////////////////////////////////////////////////\r\n// import React, { useEffect, useRef } from 'react';\r\n\r\n// function VideoBlob() {\r\n//   const socketRef = useRef(null);\r\n\r\n//   useEffect(() => {\r\n//     // Create a WebSocket connection\r\n//     socketRef.current = new WebSocket('ws://localhost:8000');\r\n\r\n//     // Listen for messages from the server\r\n//     socketRef.current.onmessage = function (event) {\r\n//       console.log('Received: ', event.data);\r\n//     };\r\n\r\n//     // Clean up the WebSocket connection when the component is unmounted\r\n//     return () => {\r\n//       socketRef.current.close();\r\n//     };\r\n//   }, []);\r\n\r\n//   const sendPing = () => {\r\n//     if (socketRef.current.readyState === WebSocket.OPEN) {\r\n//       // Send a ping message to the server\r\n//       socketRef.current.send('ping');\r\n//     }\r\n//   };\r\n\r\n//   return (\r\n//     <div className=\"App\">\r\n//       <button onClick={sendPing}>Send Ping</button>\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default VideoBlob;\r\n\r\n\r\n// App.js chunks are coming frm server but problem is here\r\n// import React, { useEffect, useRef } from \"react\";\r\n\r\n// function VideoBlob() {\r\n//   const videoRef = useRef(null);\r\n//   const wsRef = useRef(null);\r\n//   const receivedChunks = useRef([]);\r\n//   const totalBytesReceived = useRef(0);\r\n\r\n//   useEffect(() => {\r\n//     wsRef.current = new WebSocket(\"ws://localhost:8000\");\r\n\r\n//     wsRef.current.onmessage = (event) => {\r\n//       const videoChunk = event.data;\r\n//       receivedChunks.current.push(videoChunk);\r\n//       totalBytesReceived.current += videoChunk.length;\r\n\r\n//       // Check if all chunks are received (e.g., by comparing total received bytes with expected size)\r\n//       // If all chunks are received, proceed to create and play the video\r\n\r\n    \r\n//         const concatenatedChunks = new Uint8Array(totalBytesReceived.current);\r\n//         let offset = 0;\r\n//         for (const chunk of receivedChunks.current) {\r\n//           concatenatedChunks.set(chunk, offset);\r\n//           offset += chunk.length;\r\n//         }\r\n\r\n//         // Create a Blob from the concatenated chunks\r\n//         const videoBlob = new Blob([concatenatedChunks], { type: \"video/mp4\" });\r\n\r\n//         // Create a Blob URL\r\n//         const videoUrl = URL.createObjectURL(videoBlob);\r\n\r\n//         // Set the video element's src attribute to the Blob URL\r\n//         videoRef.current.src = videoUrl;\r\n      \r\n//     };\r\n\r\n//     return () => {\r\n//       wsRef.current.close();\r\n//     };\r\n//   }, []);\r\n\r\n//   return (\r\n//     <div>\r\n//       <video ref={videoRef} controls />\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default VideoBlob;\r\n\r\n\r\n// //////////////////dane przychodza ale nie odtwarza video\r\nimport React, { useEffect, useRef } from \"react\";\r\n\r\nfunction VideoPlayer() {\r\n  const videoRef = useRef(null);\r\n  const wsRef = useRef(null);\r\n  const mediaSourceRef = useRef(null);\r\n  const sourceBufferRef = useRef(null);\r\n  const bufferQueueRef = useRef([]);\r\n  const isAppendingRef = useRef(false);\r\n  const isSourceOpenRef = useRef(false);\r\n\r\n  useEffect(() => {\r\n    wsRef.current = new WebSocket(\"ws://localhost:8000\");\r\n\r\n    wsRef.current.onmessage = (event) => {\r\n      console.log(event)\r\n      if (typeof event.data === \"string\") {\r\n        console.log(\"string\")\r\n        const message = JSON.parse(event.data);\r\n\r\n        if (message.type === \"metadata\") {\r\n          console.log(\"metadata\")\r\n          const mediaSource = new MediaSource();\r\n          videoRef.current.src = URL.createObjectURL(mediaSource);\r\n          mediaSourceRef.current = mediaSource;\r\n\r\n          mediaSource.addEventListener(\"sourceopen\", handleSourceOpen);\r\n          mediaSource.addEventListener(\"sourceended\", handleSourceEnded);\r\n          mediaSource.addEventListener(\"error\", handleSourceError);\r\n        }\r\n      } else if (event.data instanceof Blob && sourceBufferRef.current) {\r\n        console.log(\"third\")\r\n        const videoData = event.data;\r\n        bufferQueueRef.current.push(videoData);\r\n\r\n        processBufferQueue();\r\n      }\r\n    };\r\n\r\n    return () => {\r\n      wsRef.current.close();\r\n    };\r\n  }, []);\r\n\r\n  const handleSourceOpen = () => {\r\n    const mediaSource = mediaSourceRef.current;\r\n    const sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"');\r\n    sourceBufferRef.current = sourceBuffer;\r\n    isSourceOpenRef.current = true;\r\n\r\n    sourceBuffer.addEventListener(\"updateend\", processBufferQueue);\r\n  };\r\n\r\n  const handleSourceEnded = () => {\r\n    console.log(\"MediaSource ended\");\r\n  };\r\n\r\n  const handleSourceError = (error) => {\r\n    console.error(\"MediaSource error:\", error);\r\n  };\r\n  const processBufferQueue = async () => {\r\n    if (isSourceOpenRef.current && !isAppendingRef.current && bufferQueueRef.current.length > 0) {\r\n      const videoData = bufferQueueRef.current.shift();\r\n      isAppendingRef.current = true;\r\n  \r\n      try {\r\n        const response = await fetch(URL.createObjectURL(videoData));\r\n        const arrayBuffer = await response.arrayBuffer();\r\n        sourceBufferRef.current.appendBuffer(arrayBuffer);\r\n      } catch (error) {\r\n        console.error(\"Error appending video data to SourceBuffer:\", error);\r\n        isAppendingRef.current = false;\r\n        processBufferQueue();\r\n      }\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <div>\r\n      <video ref={videoRef} controls />\r\n    </div>\r\n  );\r\n}\r\nexport default VideoPlayer;\r\n\r\n// /////////////17.07\r\n// import React, { useEffect, useRef } from \"react\";\r\n\r\n// const VideoPlayer = () => {\r\n//   const videoRef = useRef(null);\r\n//   const websocketRef = useRef(null);\r\n\r\n//   useEffect(() => {\r\n//     // Create a WebSocket connection\r\n//     const socket = new WebSocket(\"ws://localhost:8000\");\r\n\r\n//     socket.onopen = () => {\r\n//       console.log(\"Connected to server\");\r\n//     };\r\n\r\n//     socket.onmessage = (event) => {\r\n//       // Receive video data from the server\r\n//       const data = event.data;\r\n//       videoRef.current.src = URL.createObjectURL(data);\r\n//     };\r\n\r\n//     socket.onclose = () => {\r\n//       console.log(\"Disconnected from server\");\r\n//     };\r\n\r\n//     websocketRef.current = socket;\r\n\r\n//     return () => {\r\n//       // Clean up the WebSocket connection\r\n//       websocketRef.current.close();\r\n//     };\r\n//   }, []);\r\n\r\n//   return (\r\n//     <div>\r\n//       <video ref={videoRef} controls autoPlay />\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default VideoPlayer;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AACA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEjD,SAASC,WAAWA,CAAA,EAAG;EAAAC,EAAA;EACrB,MAAMC,QAAQ,GAAGL,MAAM,CAAC,IAAI,CAAC;EAC7B,MAAMM,KAAK,GAAGN,MAAM,CAAC,IAAI,CAAC;EAC1B,MAAMO,cAAc,GAAGP,MAAM,CAAC,IAAI,CAAC;EACnC,MAAMQ,eAAe,GAAGR,MAAM,CAAC,IAAI,CAAC;EACpC,MAAMS,cAAc,GAAGT,MAAM,CAAC,EAAE,CAAC;EACjC,MAAMU,cAAc,GAAGV,MAAM,CAAC,KAAK,CAAC;EACpC,MAAMW,eAAe,GAAGX,MAAM,CAAC,KAAK,CAAC;EAErCD,SAAS,CAAC,MAAM;IACdO,KAAK,CAACM,OAAO,GAAG,IAAIC,SAAS,CAAC,qBAAqB,CAAC;IAEpDP,KAAK,CAACM,OAAO,CAACE,SAAS,GAAIC,KAAK,IAAK;MACnCC,OAAO,CAACC,GAAG,CAACF,KAAK,CAAC;MAClB,IAAI,OAAOA,KAAK,CAACG,IAAI,KAAK,QAAQ,EAAE;QAClCF,OAAO,CAACC,GAAG,CAAC,QAAQ,CAAC;QACrB,MAAME,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACN,KAAK,CAACG,IAAI,CAAC;QAEtC,IAAIC,OAAO,CAACG,IAAI,KAAK,UAAU,EAAE;UAC/BN,OAAO,CAACC,GAAG,CAAC,UAAU,CAAC;UACvB,MAAMM,WAAW,GAAG,IAAIC,WAAW,CAAC,CAAC;UACrCnB,QAAQ,CAACO,OAAO,CAACa,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACJ,WAAW,CAAC;UACvDhB,cAAc,CAACK,OAAO,GAAGW,WAAW;UAEpCA,WAAW,CAACK,gBAAgB,CAAC,YAAY,EAAEC,gBAAgB,CAAC;UAC5DN,WAAW,CAACK,gBAAgB,CAAC,aAAa,EAAEE,iBAAiB,CAAC;UAC9DP,WAAW,CAACK,gBAAgB,CAAC,OAAO,EAAEG,iBAAiB,CAAC;QAC1D;MACF,CAAC,MAAM,IAAIhB,KAAK,CAACG,IAAI,YAAYc,IAAI,IAAIxB,eAAe,CAACI,OAAO,EAAE;QAChEI,OAAO,CAACC,GAAG,CAAC,OAAO,CAAC;QACpB,MAAMgB,SAAS,GAAGlB,KAAK,CAACG,IAAI;QAC5BT,cAAc,CAACG,OAAO,CAACsB,IAAI,CAACD,SAAS,CAAC;QAEtCE,kBAAkB,CAAC,CAAC;MACtB;IACF,CAAC;IAED,OAAO,MAAM;MACX7B,KAAK,CAACM,OAAO,CAACwB,KAAK,CAAC,CAAC;IACvB,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMP,gBAAgB,GAAGA,CAAA,KAAM;IAC7B,MAAMN,WAAW,GAAGhB,cAAc,CAACK,OAAO;IAC1C,MAAMyB,YAAY,GAAGd,WAAW,CAACe,eAAe,CAAC,4CAA4C,CAAC;IAC9F9B,eAAe,CAACI,OAAO,GAAGyB,YAAY;IACtC1B,eAAe,CAACC,OAAO,GAAG,IAAI;IAE9ByB,YAAY,CAACT,gBAAgB,CAAC,WAAW,EAAEO,kBAAkB,CAAC;EAChE,CAAC;EAED,MAAML,iBAAiB,GAAGA,CAAA,KAAM;IAC9Bd,OAAO,CAACC,GAAG,CAAC,mBAAmB,CAAC;EAClC,CAAC;EAED,MAAMc,iBAAiB,GAAIQ,KAAK,IAAK;IACnCvB,OAAO,CAACuB,KAAK,CAAC,oBAAoB,EAAEA,KAAK,CAAC;EAC5C,CAAC;EACD,MAAMJ,kBAAkB,GAAG,MAAAA,CAAA,KAAY;IACrC,IAAIxB,eAAe,CAACC,OAAO,IAAI,CAACF,cAAc,CAACE,OAAO,IAAIH,cAAc,CAACG,OAAO,CAAC4B,MAAM,GAAG,CAAC,EAAE;MAC3F,MAAMP,SAAS,GAAGxB,cAAc,CAACG,OAAO,CAAC6B,KAAK,CAAC,CAAC;MAChD/B,cAAc,CAACE,OAAO,GAAG,IAAI;MAE7B,IAAI;QACF,MAAM8B,QAAQ,GAAG,MAAMC,KAAK,CAACjB,GAAG,CAACC,eAAe,CAACM,SAAS,CAAC,CAAC;QAC5D,MAAMW,WAAW,GAAG,MAAMF,QAAQ,CAACE,WAAW,CAAC,CAAC;QAChDpC,eAAe,CAACI,OAAO,CAACiC,YAAY,CAACD,WAAW,CAAC;MACnD,CAAC,CAAC,OAAOL,KAAK,EAAE;QACdvB,OAAO,CAACuB,KAAK,CAAC,6CAA6C,EAAEA,KAAK,CAAC;QACnE7B,cAAc,CAACE,OAAO,GAAG,KAAK;QAC9BuB,kBAAkB,CAAC,CAAC;MACtB;IACF;EACF,CAAC;EAED,oBACEjC,OAAA;IAAA4C,QAAA,eACE5C,OAAA;MAAO6C,GAAG,EAAE1C,QAAS;MAAC2C,QAAQ;IAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAC9B,CAAC;AAEV;AAAChD,EAAA,CAhFQD,WAAW;AAAAkD,EAAA,GAAXlD,WAAW;AAiFpB,eAAeA,WAAW;;AAE1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA,IAAAkD,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}