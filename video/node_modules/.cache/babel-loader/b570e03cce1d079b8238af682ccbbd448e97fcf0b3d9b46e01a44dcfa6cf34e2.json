{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\msado\\\\OneDrive\\\\Pulpit\\\\video-stream\\\\video\\\\src\\\\components\\\\VideoPlayer.jsx\",\n  _s = $RefreshSig$();\n// import React, { useRef, useEffect, useState } from \"react\";\n// const VideoBlob = () => {\n//   const videoRef = useRef(null);\n//   const [videoChunks, setVideoChunks] = useState([]);\n// console.log(videoChunks)\n//   useEffect(() => {\n//     const fetchVideo = async () => {\n//       const headers = { Range: \"bytes=0-1024\" }; // Request the first chunk\n//       const response = await fetch(`http://localhost:3000/videos/sample.mp4`, { headers });\n//       const reader = response.body.getReader();\n//       const readChunk = async () => {\n//         const { done, value } = await reader.read();\n// console.log(value)\n//         if (!done) {\n//           setVideoChunks(prevChunks => [...prevChunks, value]);\n//           readChunk();\n//         }\n//       };\n//       readChunk();\n//     };\n//     fetchVideo();\n//   }, []);\n//   useEffect(() => {\n//     if (videoChunks.length > 0 && videoRef.current) {\n//       const concatenatedChunks = new Uint8Array(videoChunks.reduce((acc, chunk) => acc + chunk.length, 0));\n//       let offset = 0;\n//       videoChunks.forEach(chunk => {\n//         concatenatedChunks.set(chunk, offset);\n//         offset += chunk.length;\n//       });\n//       const blob = new Blob([concatenatedChunks], { type: \"video/mp4\" });\n//       const videoURL = URL.createObjectURL(blob);\n//       videoRef.current.src = videoURL;\n//     }\n//   }, [videoChunks]);\n//   console.log(videoChunks)\n//   return (\n//     <video ref={videoRef} width=\"320\" height=\"240\" controls autoPlay>\n//   {videoChunks.map((chunk, index) => (\n//     <source\n//       key={index}\n//       src={URL.createObjectURL(new Blob([chunk], { type: \"video/mp4\" }))}\n//       type=\"video/mp4\"\n//     />\n//   ))}\n//   Your browser does not support the video tag.\n// </video>\n//   );\n// };\n// export default VideoBlob;\n/////////////////////////////powyżej działa na krótkim filmie, poniżej na dłuzszym tez działa\n// import React, { useRef, useEffect, useState } from \"react\";\n\n// const VideoBlob = () => {\n//   const videoRef = useRef(null);\n//   const mediaSourceRef = useRef(null);\n//   const sourceBufferRef = useRef(null);\n//   const [videoChunks, setVideoChunks] = useState([]);\n\n//   useEffect(() => {\n//     const fetchVideo = async () => {\n//       const response = await fetch(`http://localhost:3000/videos/sample.mp4`);\n//       console.log(response)\n//       const reader = response.body.getReader();\n//       const chunks = [];\n\n//       const readChunk = async () => {\n//         const { done, value } = await reader.read();\n//         if (done) {\n//           // All chunks received\n//           setVideoChunks(chunks);\n//           return;\n//         }\n//         chunks.push(value);\n//         // next chunk\n//         readChunk();\n//       };\n//       // Start reading the chunks\n//       readChunk();\n//     };\n\n//     fetchVideo();\n//   },[]);\n\n//   useEffect(() => {\n//     const appendVideoChunk = () => {\n//       if (videoRef.current && videoChunks.length > 0) {\n//         const videoBlob = new Blob(videoChunks, { type: \"video/mp4\" });\n//         const videoURL = URL.createObjectURL(videoBlob);\n//         videoRef.current.src = videoURL;\n//         videoRef.current.load();\n//         videoRef.current.play().catch(handlePlayError);\n//       }\n//     };\n//     const handlePlayError = (error) => {\n//       console.error(\"Error occurred while playing the video:\", error);\n//     };\n//     appendVideoChunk();\n//   }, [videoChunks]);\n//   return (\n//     <video ref={videoRef} width=\"320\" height=\"240\" controls autoPlay>\n//       Your browser does not support the video tag.\n//     </video>\n//   );\n// };\n// export default VideoBlob;\n// //////////////////////////////////////////////////////////////////////////\n\n// import React, { useRef, useEffect, useState } from \"react\";\n\n// const VideoBlob = () => {\n//   const videoRef = useRef(null);\n//   const mediaSourceRef = useRef(null);\n//   const sourceBufferRef = useRef(null);\n//   const [videoChunks, setVideoChunks] = useState([]);\n\n//   useEffect(() => {\n//     const fetchVideo = async () => {\n//       // const response = await fetch(`http://localhost:3000/videos`);\n//       const response = await fetch(`http://192.168.128.224:8888/startvideo/?token=test&deviceid=2`);\n//       console.log(response.body)\n//       const reader = response.body.getReader();\n//       const chunks = [];\n//       const readChunk = async () => {\n//         const { done, value } = await reader.read();\n//         if (done) {\n//           // All chunks have been received\n//           setVideoChunks(chunks);\n//           console.log(videoChunks)\n//           return;\n//         }\n//         chunks.push(value);\n//         // console.log(chunks)\n//         // Read the next chunk\n//         readChunk();\n//       };\n\n//       // Start reading the chunks\n//       readChunk();\n//     };\n\n//     fetchVideo();\n//   }, []);\n\n//   useEffect(() => {\n//     if (videoRef.current && videoChunks.length > 0) {\n//       if (!mediaSourceRef.current) {\n//         mediaSourceRef.current = new MediaSource();\n//         videoRef.current.src = URL.createObjectURL(mediaSourceRef.current);\n//         console.log(\"first\")\n//       }\n\n// if (!sourceBufferRef.current && mediaSourceRef.current.readyState === \"open\") {\n//   sourceBufferRef.current = mediaSourceRef.current.addSourceBuffer(\"video/mp4; codecs=\\\"avc1.4D401E, mp4a.40.2\\\"\");\n// }\n\n//       const appendVideoChunk = () => {\n//         if (sourceBufferRef.current) {\n//           const chunk = videoChunks.shift();\n//           console.log(chunk)\n//           if (chunk) {\n//             sourceBufferRef.current.appendBuffer(chunk);\n\n//           }\n//         }\n//       };\n\n//       const handlePlayError = (error) => {\n//         console.error(\"Error occurred while playing the video:\", error);\n//       };\n\n//       const handleSourceOpen = () => {\n//         if (mediaSourceRef.current.readyState === \"open\") {\n//           console.log(\"open\")\n//           appendVideoChunk();\n//         }\n\n//       };\n\n//       const handleSourceEnded = () => {\n//         if (videoChunks.length === 0 && mediaSourceRef.current.readyState === \"open\") {\n//           mediaSourceRef.current.endOfStream();\n//           console.log(\"end\")\n//         }\n//       };\n\n//       if (sourceBufferRef.current && mediaSourceRef.current) {\n//         console.log(\"adding\")\n//         sourceBufferRef.current.addEventListener(\"updateend\", appendVideoChunk);\n//         mediaSourceRef.current.addEventListener(\"sourceopen\", handleSourceOpen);\n//         mediaSourceRef.current.addEventListener(\"sourceended\", handleSourceEnded);\n//         videoRef.current.addEventListener(\"error\", handlePlayError);\n//       }\n\n//       return () => {\n//         console.log(\"removing\")\n//         if (sourceBufferRef.current && mediaSourceRef.current) {\n//           sourceBufferRef.current.removeEventListener(\"updateend\", appendVideoChunk);\n//           mediaSourceRef.current.removeEventListener(\"sourceopen\", handleSourceOpen);\n//           mediaSourceRef.current.removeEventListener(\"sourceended\", handleSourceEnded);\n\n//           videoRef.current.removeEventListener(\"error\", handlePlayError);\n//         }\n//       };\n//     }\n//   }, [videoChunks]);\n\n//   return (\n//     <video ref={videoRef} width=\"320\" height=\"240\" controls autoPlay>\n//       Your browser does not support the video tag.\n//     </video>\n//   );\n// };\n\n// export default VideoBlob;\n//////////////////////////////////Sylwester \n// import React, { useEffect, useRef } from 'react';\n\n// function VideoBlob() {\n//   const videoRef = useRef(null);\n\n//   const fetchAB = async (url) => {\n//     console.log(url);\n//     const response = await fetch(url);\n//     const buffer = await response.arrayBuffer();\n//     console.log(buffer)\n//     return buffer;\n//   };\n\n//   useEffect(() => {\n//     const fetchAndAppendBuffer = async (url, sourceBuffer, index) => {\n//       if (index >= 100) {\n//         return; // Exit condition to stop recursion\n//       }\n\n//       const buf = await fetchAB(url);\n//       sourceBuffer.addEventListener('updateend', () => {\n//         // console.log(sourceBuffer.buffered);\n//         // console.log(mediaSource.readyState); // ended\n//       });\n//       sourceBuffer.appendBuffer(buf);\n\n//       await fetchAndAppendBuffer(url, sourceBuffer, index + 1); // Recursively call the function for the next iteration\n//     };\n\n//     const startVideo = async () => {\n//       // const assetURL = '/videos/sample.mp4';\n//       const assetURL = 'http://192.168.128.224:8888/startvideo/?token=test&deviceid=2';\n//       const mimeCodec = 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"';\n\n//       if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {\n//         const mediaSource = new MediaSource();\n//         videoRef.current.src = URL.createObjectURL(mediaSource);\n\n//         mediaSource.addEventListener('sourceopen', async () => {\n//           const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\n//           console.log(sourceBuffer.appendBuffer.length)\n//           await fetchAndAppendBuffer(assetURL, sourceBuffer, 0);\n//         });\n//       } else {\n//         console.error('Unsupported MIME type or codec: ', mimeCodec);\n//       }\n//     };\n\n//     startVideo();\n//   }, []);\n\n//   return (\n//     <div>\n//       <video ref={videoRef} controls />\n//     </div>\n//   );\n// }\n\n// export default VideoBlob;\n// //////////////////////////////\n// import React, { useEffect, useRef } from 'react';\n\n// function VideoBlob() {\n//   const videoRef = useRef(null);\n\n//   const fetchAB = async (url) => {\n//     console.log(url);\n//     const response = await fetch(url);\n//     const buffer = await response.arrayBuffer();\n//     console.log(buffer)\n//     return buffer;\n//   };\n\n// useEffect(() => {\n//   const appendVideoChunks = async (url, sourceBuffer, chunkCount) => {\n//     if (chunkCount <= 0) {\n//       return; // Exit condition to stop recursion\n//     }\n\n//     const buf = await fetchAB(url);\n//     sourceBuffer.addEventListener('updateend', () => {\n//       // console.log(sourceBuffer.buffered);\n//     });\n\n//     try {\n//       sourceBuffer.appendBuffer(buf);\n//     } catch (error) {\n//       console.error('Error appending video chunk:', error);\n//       return; // Exit the function if an error occurs\n//     }\n\n//     await appendVideoChunks(url, sourceBuffer, chunkCount - 1); // Recursively call the function for the next iteration\n//   };\n\n//   const startVideo = async () => {\n//     const assetURL = 'http://localhost:3000/videos/sample.mp4';\n//     const mimeCodec = 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"';\n\n//     if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {\n//       const mediaSource = new MediaSource();\n//       videoRef.current.src = URL.createObjectURL(mediaSource);\n\n//       mediaSource.addEventListener('sourceopen', async () => {\n//         try {\n//           const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\n//           await appendVideoChunks(assetURL, sourceBuffer, 100); // Append 100 video chunks\n//         } catch (error) {\n//           console.error('Error creating source buffer:', error);\n//         }\n//       });\n//     } else {\n//       console.error('Unsupported MIME type or codec: ', mimeCodec);\n//     }\n//   };\n\n//   startVideo();\n// }, []);\n\n//   return (\n//     <div>\n//       <video ref={videoRef} controls />\n//     </div>\n//   );\n// }\n\n// export default VideoBlob;\n// /////////////////////////////////////////////////////////websocket\n// import React, { useRef } from 'react';\n\n// const VideoBlob = () => {\n//   const videoRef = useRef(null);\n//   const wsRef = useRef(null);\n\n//   const handleStart = () => {\n//     // Connect to the WebSocket server\n//     wsRef.current = new WebSocket('ws://localhost:8080');\n//     console.log(\"start\")\n\n//     // Event listener for the WebSocket open event\n//     wsRef.current.onopen = () => {\n//       console.log('WebSocket connection established.');\n//     };\n\n//     // Event listener for the WebSocket close event\n//     wsRef.current.onclose = () => {\n//       console.log('WebSocket connection closed.');\n//     };\n\n//     // Event listener for the video \"play\" event\n//     videoRef.current.addEventListener('play', handleVideoPlay);\n//   };\n\n//   const handleStop = () => {\n//     // Close the WebSocket connection\n//     wsRef.current.close();\n\n//     // Remove the event listener for the video \"play\" event\n//     videoRef.current.removeEventListener('play', handleVideoPlay);\n//   };\n\n//   const handleVideoPlay = () => {\n//     // Create a canvas element to capture video frames\n//     const canvas = document.createElement('canvas');\n//     const ctx = canvas.getContext('2d');\n\n//     const captureFrame = () => {\n//       if (videoRef.current.paused || videoRef.current.ended) {\n//         return;\n//       }\n\n//       // Draw the current video frame on the canvas\n//       ctx.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);\n\n//       // Get the image data from the canvas\n//       const imageData = canvas.toDataURL('image/jpeg');\n\n//       // Send the image data as a WebSocket message to the server\n//       wsRef.current.send(imageData);\n\n//       // Capture the next video frame\n//       requestAnimationFrame(captureFrame);\n//     };\n\n//     // Start capturing video frames\n//     requestAnimationFrame(captureFrame);\n//   };\n\n//   return (\n//     <div>\n//       <video ref={videoRef} width=\"320\" height=\"240\" controls>\n//         <source src=\"path/to/video.mp4\" type=\"video/mp4\" />\n//       </video>\n//       <button onClick={handleStart}>Start</button>\n//       <button onClick={handleStop}>Stop</button>\n//     </div>\n//   );\n// };\n\n// export default VideoBlob;\n// /////////////////////\n// import React, { useEffect, useRef, useState } from 'react';\n\n// const VideoBlob = () => {\n//   const videoRef = useRef(null);\n//   const assetURL = 'http://localhost:3000/videos/sample.mp4';\n//   const mimeCodec = 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"';\n//   const [isLoading, setIsLoading] = useState(true);\n//   const [error, setError] = useState(null);\n\n//   useEffect(() => {\n//     let mediaSource;\n//     let sourceBuffer;\n\n//     const fetchAB = async (url) => {\n//       try {\n//         const response = await fetch(url);\n//         const buffer = await response.arrayBuffer();\n//         return buffer;\n//       } catch (error) {\n//         throw new Error('Error fetching video: ' + error.message);\n//       }\n//     };\n\n//     const initializeMediaSource = async () => {\n//       try {\n//         if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {\n//           mediaSource = new MediaSource();\n//           videoRef.current.src = URL.createObjectURL(mediaSource);\n//           mediaSource.addEventListener('sourceopen', handleSourceOpen);\n//         } else {\n//           throw new Error('Unsupported MIME type or codec: ' + mimeCodec);\n//         }\n//       } catch (error) {\n//         setError(error.message);\n//       }\n//     };\n\n//     const handleSourceOpen = async () => {\n//       try {\n//         sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\n//         sourceBuffer.addEventListener('updateend', handleUpdateEnd);\n//         await appendVideoChunks(assetURL, sourceBuffer);\n//       } catch (error) {\n//         setError('Error initializing source buffer: ' + error.message);\n//       }\n//     };\n\n//     const appendVideoChunks = async (url, sourceBuffer) => {\n//       try {\n//         const buffer = await fetchAB(url);\n//         sourceBuffer.appendBuffer(buffer);\n//       } catch (error) {\n//         setError('Error appending video chunk: ' + error.message);\n//       }\n//     };\n\n//     initializeMediaSource();\n\n//     return () => {\n//       if (sourceBuffer) {\n//         sourceBuffer.removeEventListener('updateend', handleUpdateEnd);\n//       }\n//       if (mediaSource) {\n//         mediaSource.removeEventListener('sourceopen', handleSourceOpen);\n//         mediaSource = null;\n//       }\n//     };\n//   }, []);\n\n//   const handleUpdateEnd = () => {\n//     setIsLoading(false);\n//     videoRef.current.play().catch((error) => {\n//       setError('Error playing video: ' + error.message);\n//     });\n//   };\n\n//   return (\n//     <div>\n//       {isLoading && <div>Loading...</div>}\n//       {error && <div>Error: {error}</div>}\n//       <video ref={videoRef} controls></video>\n//     </div>\n//   );\n// };\n\n// export default VideoBlob;\n\n// App.js chunks are coming frm server but problem is here\n// import React, { useEffect, useRef } from \"react\";\n\n// function VideoBlob() {\n//   const videoRef = useRef(null);\n//   const wsRef = useRef(null);\n//   const receivedChunks = useRef([]);\n//   const totalBytesReceived = useRef(0);\n\n//   useEffect(() => {\n//     wsRef.current = new WebSocket(\"ws://localhost:8000\");\n\n//     wsRef.current.onmessage = (event) => {\n//       const videoChunk = event.data;\n//       receivedChunks.current.push(videoChunk);\n//       totalBytesReceived.current += videoChunk.length;\n\n//       // Check if all chunks are received (e.g., by comparing total received bytes with expected size)\n//       // If all chunks are received, proceed to create and play the video\n\n//         const concatenatedChunks = new Uint8Array(totalBytesReceived.current);\n//         let offset = 0;\n//         for (const chunk of receivedChunks.current) {\n//           concatenatedChunks.set(chunk, offset);\n//           offset += chunk.length;\n//         }\n\n//         // Create a Blob from the concatenated chunks\n//         const videoBlob = new Blob([concatenatedChunks], { type: \"video/mp4\" });\n\n//         // Create a Blob URL\n//         const videoUrl = URL.createObjectURL(videoBlob);\n\n//         // Set the video element's src attribute to the Blob URL\n//         videoRef.current.src = videoUrl;\n\n//     };\n\n//     return () => {\n//       wsRef.current.close();\n//     };\n//   }, []);\n\n//   return (\n//     <div>\n//       <video ref={videoRef} controls />\n//     </div>\n//   );\n// }\n\n// export default VideoBlob;\n\n// //////////////////dane przychodza ale nie odtwarza video\n// import React, { useEffect, useRef } from \"react\";\n\n// function VideoBlob() {\n//   const videoRef = useRef(null);\n//   const wsRef = useRef(null);\n//   const mediaSourceRef = useRef(null);\n//   const sourceBufferRef = useRef(null);\n//   const bufferQueueRef = useRef([]);\n//   const isAppendingRef = useRef(false);\n//   const isSourceOpenRef = useRef(false);\n\n//   useEffect(() => {\n//     wsRef.current = new WebSocket(\"ws://localhost:8000\");\n\n//     wsRef.current.onmessage = (event) => {\n//       console.log(event)\n//       if (typeof event.data === \"string\") {\n//         console.log(\"string\")\n//         const message = JSON.parse(event.data);\n\n//         if (message.type === \"metadata\") {\n//           console.log(\"metadata\")\n//           const mediaSource = new MediaSource();\n//           videoRef.current.src = URL.createObjectURL(mediaSource);\n//           mediaSourceRef.current = mediaSource;\n\n//           mediaSource.addEventListener(\"sourceopen\", handleSourceOpen);\n//           mediaSource.addEventListener(\"sourceended\", handleSourceEnded);\n//           mediaSource.addEventListener(\"error\", handleSourceError);\n//         }\n//       } else if (event.data instanceof Blob && sourceBufferRef.current) {\n//         console.log(\"third\")\n//         const videoData = event.data;\n//         bufferQueueRef.current.push(videoData);\n\n//         processBufferQueue();\n//       }\n//     };\n\n//     return () => {\n//       wsRef.current.close();\n//     };\n//   }, []);\n\n//   const handleSourceOpen = () => {\n//     const mediaSource = mediaSourceRef.current;\n//     const sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"');\n//     sourceBufferRef.current = sourceBuffer;\n//     isSourceOpenRef.current = true;\n\n//     sourceBuffer.addEventListener(\"updateend\", processBufferQueue);\n//   };\n\n//   const handleSourceEnded = () => {\n//     console.log(\"MediaSource ended\");\n//   };\n\n//   const handleSourceError = (error) => {\n//     console.error(\"MediaSource error:\", error);\n//   };\n//   const processBufferQueue = async () => {\n//     if (isSourceOpenRef.current && !isAppendingRef.current && bufferQueueRef.current.length > 0) {\n//       const videoData = bufferQueueRef.current.shift();\n//       isAppendingRef.current = true;\n\n//       try {\n//         const response = await fetch(URL.createObjectURL(videoData));\n//         const arrayBuffer = await response.arrayBuffer();\n//         sourceBufferRef.current.appendBuffer(arrayBuffer);\n//       } catch (error) {\n//         console.error(\"Error appending video data to SourceBuffer:\", error);\n//         isAppendingRef.current = false;\n//         processBufferQueue();\n//       }\n//     }\n//   };\n\n//   return (\n//     <div>\n//       <video ref={videoRef} controls />\n//     </div>\n//   );\n// }\n// export default VideoBlob;\n// /////////////17.07\n// import React, { useEffect, useRef } from \"react\";\n\n// const VideoPlayer = () => {\n//   const videoRef = useRef(null);\n//   const websocketRef = useRef(null);\n\n//   useEffect(() => {\n//     // Create a WebSocket connection\n//     const socket = new WebSocket(\"ws://localhost:8000\");\n\n//     socket.onopen = () => {\n//       console.log(\"Connected to server\");\n//     };\n\n//     socket.onmessage = (event) => {\n//       // Receive video data from the server\n//       const data = event.data;\n//       videoRef.current.src = URL.createObjectURL(data);\n//     };\n\n//     socket.onclose = () => {\n//       console.log(\"Disconnected from server\");\n//     };\n\n//     websocketRef.current = socket;\n\n//     return () => {\n//       // Clean up the WebSocket connection\n//       websocketRef.current.close();\n//     };\n//   }, []);\n\n//   return (\n//     <div>\n//       <video ref={videoRef} controls autoPlay />\n//     </div>\n//   );\n// };\n\n// export default VideoPlayer;\nimport React, { useEffect, useRef, useCallback } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoPlayer = () => {\n  _s();\n  const videoRef = useRef(null);\n  const mediaSourceRef = useRef(null);\n  const sourceBufferRef = useRef(null);\n  const websocketRef = useRef(null);\n  const queueRef = useRef([]);\n  const handleSourceOpen = useCallback(() => {\n    sourceBufferRef.current = mediaSourceRef.current.addSourceBuffer(\"video/mp4; codecs=\\\"avc1.4D401E, mp4a.40.2\\\"\");\n    sourceBufferRef.current.addEventListener(\"updateend\", handleUpdateEnd);\n  }, []);\n  const handleUpdateEnd = useCallback(() => {\n    if (queueRef.current.length > 0) {\n      const blob = queueRef.current.shift();\n      appendToSourceBuffer(blob);\n    }\n  }, []);\n  const appendToSourceBuffer = useCallback(blob => {\n    if (sourceBufferRef.current) {\n      const reader = new FileReader();\n      reader.onload = function () {\n        const arrayBuffer = reader.result;\n        const uint8Array = new Uint8Array(arrayBuffer);\n        sourceBufferRef.current.appendBuffer(uint8Array);\n      };\n      reader.readAsArrayBuffer(blob);\n    }\n  }, []);\n  useEffect(() => {\n    if (!websocketRef.current) {\n      const socket = new WebSocket(\"ws://localhost:8000\");\n      socket.onopen = () => {\n        console.log(\"Connected to server\");\n      };\n      socket.onmessage = event => {\n        const blob = event.data;\n        if (!mediaSourceRef.current) {\n          mediaSourceRef.current = new MediaSource();\n          videoRef.current.src = URL.createObjectURL(mediaSourceRef.current);\n          console.log(videoRef.current.src);\n          mediaSourceRef.current.addEventListener(\"sourceopen\", handleSourceOpen);\n        }\n        if (sourceBufferRef.current && !sourceBufferRef.current.updating && queueRef.current.length === 0) {\n          console.log(\"blob\");\n          appendToSourceBuffer(blob);\n        } else {\n          queueRef.current.push(blob);\n          console.log(\"queue\");\n        }\n      };\n      socket.onclose = () => {\n        console.log(\"Disconnected from server\");\n      };\n      websocketRef.current = socket;\n    }\n    return () => {\n      if (websocketRef.current) {\n        websocketRef.current.close();\n      }\n    };\n  }, [handleSourceOpen, appendToSourceBuffer]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      controls: true,\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 766,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 765,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoPlayer, \"68cZ2coxAwv4l0UYTvZX6Suve6A=\");\n_c = VideoPlayer;\nexport default VideoPlayer;\n\n// Random ints working///////////////////////////////////\n// import React, { useState, useEffect } from 'react';\n\n// const VideoBlob = () => {\n//   const [currentData, setCurrentData] = useState([]);\n\n//   useEffect(() => {\n//     const ws = new WebSocket(\"ws://localhost:8888/\");\n\n//     ws.onopen = () => {\n//       console.log('Opened Connection!');\n//     };\n\n//     ws.onmessage = (event) => {\n//       setCurrentData(JSON.parse(event.data));\n//     };\n\n//     ws.onclose = () => {\n//       console.log('Closed Connection!');\n//     };\n\n//     return () => {\n//       ws.close();\n//     };\n//   }, []);\n\n//   console.log(currentData);\n\n//   return (\n//     <div>\n//       {currentData.map((cd)=>(\n//         <div>\n//           <p>{cd.name}</p>\n//           <p>{cd.number}</p>\n//         </div>\n//       ))}\n\n//     </div>\n//   );\n// };\n\n// export default VideoBlob;\n\n// PING_PONG////////////////////////////////////////////////\n// import React, { useEffect, useRef } from 'react';\n\n// function VideoBlob() {\n//   const socketRef = useRef(null);\n\n//   useEffect(() => {\n//     // Create a WebSocket connection\n//     socketRef.current = new WebSocket('ws://localhost:8000');\n\n//     // Listen for messages from the server\n//     socketRef.current.onmessage = function (event) {\n//       console.log('Received: ', event.data);\n//     };\n\n//     // Clean up the WebSocket connection when the component is unmounted\n//     return () => {\n//       socketRef.current.close();\n//     };\n//   }, []);\n\n//   const sendPing = () => {\n//     if (socketRef.current.readyState === WebSocket.OPEN) {\n//       // Send a ping message to the server\n//       socketRef.current.send('ping');\n//     }\n//   };\n\n//   return (\n//     <div className=\"App\">\n//       <button onClick={sendPing}>Send Ping</button>\n//     </div>\n//   );\n// }\n\n// export default VideoBlob;\nvar _c;\n$RefreshReg$(_c, \"VideoPlayer\");","map":{"version":3,"names":["React","useEffect","useRef","useCallback","jsxDEV","_jsxDEV","VideoPlayer","_s","videoRef","mediaSourceRef","sourceBufferRef","websocketRef","queueRef","handleSourceOpen","current","addSourceBuffer","addEventListener","handleUpdateEnd","length","blob","shift","appendToSourceBuffer","reader","FileReader","onload","arrayBuffer","result","uint8Array","Uint8Array","appendBuffer","readAsArrayBuffer","socket","WebSocket","onopen","console","log","onmessage","event","data","MediaSource","src","URL","createObjectURL","updating","push","onclose","close","children","ref","controls","autoPlay","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/msado/OneDrive/Pulpit/video-stream/video/src/components/VideoPlayer.jsx"],"sourcesContent":["// import React, { useRef, useEffect, useState } from \"react\";\r\n// const VideoBlob = () => {\r\n//   const videoRef = useRef(null);\r\n//   const [videoChunks, setVideoChunks] = useState([]);\r\n// console.log(videoChunks)\r\n//   useEffect(() => {\r\n//     const fetchVideo = async () => {\r\n//       const headers = { Range: \"bytes=0-1024\" }; // Request the first chunk\r\n//       const response = await fetch(`http://localhost:3000/videos/sample.mp4`, { headers });\r\n//       const reader = response.body.getReader();\r\n//       const readChunk = async () => {\r\n//         const { done, value } = await reader.read();\r\n// console.log(value)\r\n//         if (!done) {\r\n//           setVideoChunks(prevChunks => [...prevChunks, value]);\r\n//           readChunk();\r\n//         }\r\n//       };\r\n//       readChunk();\r\n//     };\r\n//     fetchVideo();\r\n//   }, []);\r\n//   useEffect(() => {\r\n//     if (videoChunks.length > 0 && videoRef.current) {\r\n//       const concatenatedChunks = new Uint8Array(videoChunks.reduce((acc, chunk) => acc + chunk.length, 0));\r\n//       let offset = 0;\r\n//       videoChunks.forEach(chunk => {\r\n//         concatenatedChunks.set(chunk, offset);\r\n//         offset += chunk.length;\r\n//       });\r\n//       const blob = new Blob([concatenatedChunks], { type: \"video/mp4\" });\r\n//       const videoURL = URL.createObjectURL(blob);\r\n//       videoRef.current.src = videoURL;\r\n//     }\r\n//   }, [videoChunks]);\r\n//   console.log(videoChunks)\r\n//   return (\r\n//     <video ref={videoRef} width=\"320\" height=\"240\" controls autoPlay>\r\n//   {videoChunks.map((chunk, index) => (\r\n//     <source\r\n//       key={index}\r\n//       src={URL.createObjectURL(new Blob([chunk], { type: \"video/mp4\" }))}\r\n//       type=\"video/mp4\"\r\n//     />\r\n//   ))}\r\n//   Your browser does not support the video tag.\r\n// </video>\r\n//   );\r\n// };\r\n// export default VideoBlob;\r\n/////////////////////////////powyżej działa na krótkim filmie, poniżej na dłuzszym tez działa\r\n// import React, { useRef, useEffect, useState } from \"react\";\r\n\r\n// const VideoBlob = () => {\r\n//   const videoRef = useRef(null);\r\n//   const mediaSourceRef = useRef(null);\r\n//   const sourceBufferRef = useRef(null);\r\n//   const [videoChunks, setVideoChunks] = useState([]);\r\n\r\n//   useEffect(() => {\r\n//     const fetchVideo = async () => {\r\n//       const response = await fetch(`http://localhost:3000/videos/sample.mp4`);\r\n//       console.log(response)\r\n//       const reader = response.body.getReader();\r\n//       const chunks = [];\r\n\r\n//       const readChunk = async () => {\r\n//         const { done, value } = await reader.read();\r\n//         if (done) {\r\n//           // All chunks received\r\n//           setVideoChunks(chunks);\r\n//           return;\r\n//         }\r\n//         chunks.push(value);\r\n//         // next chunk\r\n//         readChunk();\r\n//       };\r\n//       // Start reading the chunks\r\n//       readChunk();\r\n//     };\r\n\r\n//     fetchVideo();\r\n//   },[]);\r\n\r\n//   useEffect(() => {\r\n//     const appendVideoChunk = () => {\r\n//       if (videoRef.current && videoChunks.length > 0) {\r\n//         const videoBlob = new Blob(videoChunks, { type: \"video/mp4\" });\r\n//         const videoURL = URL.createObjectURL(videoBlob);\r\n//         videoRef.current.src = videoURL;\r\n//         videoRef.current.load();\r\n//         videoRef.current.play().catch(handlePlayError);\r\n//       }\r\n//     };\r\n//     const handlePlayError = (error) => {\r\n//       console.error(\"Error occurred while playing the video:\", error);\r\n//     };\r\n//     appendVideoChunk();\r\n//   }, [videoChunks]);\r\n//   return (\r\n//     <video ref={videoRef} width=\"320\" height=\"240\" controls autoPlay>\r\n//       Your browser does not support the video tag.\r\n//     </video>\r\n//   );\r\n// };\r\n// export default VideoBlob;\r\n// //////////////////////////////////////////////////////////////////////////\r\n\r\n// import React, { useRef, useEffect, useState } from \"react\";\r\n\r\n// const VideoBlob = () => {\r\n//   const videoRef = useRef(null);\r\n//   const mediaSourceRef = useRef(null);\r\n//   const sourceBufferRef = useRef(null);\r\n//   const [videoChunks, setVideoChunks] = useState([]);\r\n\r\n//   useEffect(() => {\r\n//     const fetchVideo = async () => {\r\n//       // const response = await fetch(`http://localhost:3000/videos`);\r\n//       const response = await fetch(`http://192.168.128.224:8888/startvideo/?token=test&deviceid=2`);\r\n//       console.log(response.body)\r\n//       const reader = response.body.getReader();\r\n//       const chunks = [];\r\n//       const readChunk = async () => {\r\n//         const { done, value } = await reader.read();\r\n//         if (done) {\r\n//           // All chunks have been received\r\n//           setVideoChunks(chunks);\r\n//           console.log(videoChunks)\r\n//           return;\r\n//         }\r\n//         chunks.push(value);\r\n//         // console.log(chunks)\r\n//         // Read the next chunk\r\n//         readChunk();\r\n//       };\r\n\r\n//       // Start reading the chunks\r\n//       readChunk();\r\n//     };\r\n\r\n//     fetchVideo();\r\n//   }, []);\r\n\r\n//   useEffect(() => {\r\n//     if (videoRef.current && videoChunks.length > 0) {\r\n//       if (!mediaSourceRef.current) {\r\n//         mediaSourceRef.current = new MediaSource();\r\n//         videoRef.current.src = URL.createObjectURL(mediaSourceRef.current);\r\n//         console.log(\"first\")\r\n//       }\r\n  \r\n\r\n\r\n// if (!sourceBufferRef.current && mediaSourceRef.current.readyState === \"open\") {\r\n//   sourceBufferRef.current = mediaSourceRef.current.addSourceBuffer(\"video/mp4; codecs=\\\"avc1.4D401E, mp4a.40.2\\\"\");\r\n// }\r\n\r\n//       const appendVideoChunk = () => {\r\n//         if (sourceBufferRef.current) {\r\n//           const chunk = videoChunks.shift();\r\n//           console.log(chunk)\r\n//           if (chunk) {\r\n//             sourceBufferRef.current.appendBuffer(chunk);\r\n       \r\n//           }\r\n//         }\r\n//       };\r\n  \r\n//       const handlePlayError = (error) => {\r\n//         console.error(\"Error occurred while playing the video:\", error);\r\n//       };\r\n  \r\n//       const handleSourceOpen = () => {\r\n//         if (mediaSourceRef.current.readyState === \"open\") {\r\n//           console.log(\"open\")\r\n//           appendVideoChunk();\r\n//         }\r\n       \r\n//       };\r\n  \r\n//       const handleSourceEnded = () => {\r\n//         if (videoChunks.length === 0 && mediaSourceRef.current.readyState === \"open\") {\r\n//           mediaSourceRef.current.endOfStream();\r\n//           console.log(\"end\")\r\n//         }\r\n//       };\r\n  \r\n//       if (sourceBufferRef.current && mediaSourceRef.current) {\r\n//         console.log(\"adding\")\r\n//         sourceBufferRef.current.addEventListener(\"updateend\", appendVideoChunk);\r\n//         mediaSourceRef.current.addEventListener(\"sourceopen\", handleSourceOpen);\r\n//         mediaSourceRef.current.addEventListener(\"sourceended\", handleSourceEnded);\r\n//         videoRef.current.addEventListener(\"error\", handlePlayError);\r\n//       }\r\n  \r\n//       return () => {\r\n//         console.log(\"removing\")\r\n//         if (sourceBufferRef.current && mediaSourceRef.current) {\r\n//           sourceBufferRef.current.removeEventListener(\"updateend\", appendVideoChunk);\r\n//           mediaSourceRef.current.removeEventListener(\"sourceopen\", handleSourceOpen);\r\n//           mediaSourceRef.current.removeEventListener(\"sourceended\", handleSourceEnded);\r\n    \r\n//           videoRef.current.removeEventListener(\"error\", handlePlayError);\r\n//         }\r\n//       };\r\n//     }\r\n//   }, [videoChunks]);\r\n\r\n//   return (\r\n//     <video ref={videoRef} width=\"320\" height=\"240\" controls autoPlay>\r\n//       Your browser does not support the video tag.\r\n//     </video>\r\n//   );\r\n// };\r\n\r\n// export default VideoBlob;\r\n//////////////////////////////////Sylwester \r\n// import React, { useEffect, useRef } from 'react';\r\n\r\n// function VideoBlob() {\r\n//   const videoRef = useRef(null);\r\n\r\n//   const fetchAB = async (url) => {\r\n//     console.log(url);\r\n//     const response = await fetch(url);\r\n//     const buffer = await response.arrayBuffer();\r\n//     console.log(buffer)\r\n//     return buffer;\r\n//   };\r\n\r\n\r\n//   useEffect(() => {\r\n//     const fetchAndAppendBuffer = async (url, sourceBuffer, index) => {\r\n//       if (index >= 100) {\r\n//         return; // Exit condition to stop recursion\r\n//       }\r\n\r\n//       const buf = await fetchAB(url);\r\n//       sourceBuffer.addEventListener('updateend', () => {\r\n//         // console.log(sourceBuffer.buffered);\r\n//         // console.log(mediaSource.readyState); // ended\r\n//       });\r\n//       sourceBuffer.appendBuffer(buf);\r\n\r\n    \r\n//       await fetchAndAppendBuffer(url, sourceBuffer, index + 1); // Recursively call the function for the next iteration\r\n//     };\r\n\r\n//     const startVideo = async () => {\r\n//       // const assetURL = '/videos/sample.mp4';\r\n//       const assetURL = 'http://192.168.128.224:8888/startvideo/?token=test&deviceid=2';\r\n//       const mimeCodec = 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"';\r\n\r\n//       if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {\r\n//         const mediaSource = new MediaSource();\r\n//         videoRef.current.src = URL.createObjectURL(mediaSource);\r\n\r\n//         mediaSource.addEventListener('sourceopen', async () => {\r\n//           const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\r\n//           console.log(sourceBuffer.appendBuffer.length)\r\n//           await fetchAndAppendBuffer(assetURL, sourceBuffer, 0);\r\n//         });\r\n//       } else {\r\n//         console.error('Unsupported MIME type or codec: ', mimeCodec);\r\n//       }\r\n//     };\r\n\r\n//     startVideo();\r\n//   }, []);\r\n\r\n//   return (\r\n//     <div>\r\n//       <video ref={videoRef} controls />\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default VideoBlob;\r\n// //////////////////////////////\r\n// import React, { useEffect, useRef } from 'react';\r\n\r\n// function VideoBlob() {\r\n//   const videoRef = useRef(null);\r\n\r\n//   const fetchAB = async (url) => {\r\n//     console.log(url);\r\n//     const response = await fetch(url);\r\n//     const buffer = await response.arrayBuffer();\r\n//     console.log(buffer)\r\n//     return buffer;\r\n//   };\r\n\r\n\r\n// useEffect(() => {\r\n//   const appendVideoChunks = async (url, sourceBuffer, chunkCount) => {\r\n//     if (chunkCount <= 0) {\r\n//       return; // Exit condition to stop recursion\r\n//     }\r\n\r\n//     const buf = await fetchAB(url);\r\n//     sourceBuffer.addEventListener('updateend', () => {\r\n//       // console.log(sourceBuffer.buffered);\r\n//     });\r\n\r\n//     try {\r\n//       sourceBuffer.appendBuffer(buf);\r\n//     } catch (error) {\r\n//       console.error('Error appending video chunk:', error);\r\n//       return; // Exit the function if an error occurs\r\n//     }\r\n\r\n//     await appendVideoChunks(url, sourceBuffer, chunkCount - 1); // Recursively call the function for the next iteration\r\n//   };\r\n\r\n//   const startVideo = async () => {\r\n//     const assetURL = 'http://localhost:3000/videos/sample.mp4';\r\n//     const mimeCodec = 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"';\r\n\r\n//     if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {\r\n//       const mediaSource = new MediaSource();\r\n//       videoRef.current.src = URL.createObjectURL(mediaSource);\r\n\r\n//       mediaSource.addEventListener('sourceopen', async () => {\r\n//         try {\r\n//           const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\r\n//           await appendVideoChunks(assetURL, sourceBuffer, 100); // Append 100 video chunks\r\n//         } catch (error) {\r\n//           console.error('Error creating source buffer:', error);\r\n//         }\r\n//       });\r\n//     } else {\r\n//       console.error('Unsupported MIME type or codec: ', mimeCodec);\r\n//     }\r\n//   };\r\n\r\n//   startVideo();\r\n// }, []);\r\n\r\n\r\n//   return (\r\n//     <div>\r\n//       <video ref={videoRef} controls />\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default VideoBlob;\r\n// /////////////////////////////////////////////////////////websocket\r\n// import React, { useRef } from 'react';\r\n\r\n// const VideoBlob = () => {\r\n//   const videoRef = useRef(null);\r\n//   const wsRef = useRef(null);\r\n\r\n//   const handleStart = () => {\r\n//     // Connect to the WebSocket server\r\n//     wsRef.current = new WebSocket('ws://localhost:8080');\r\n//     console.log(\"start\")\r\n\r\n//     // Event listener for the WebSocket open event\r\n//     wsRef.current.onopen = () => {\r\n//       console.log('WebSocket connection established.');\r\n//     };\r\n\r\n//     // Event listener for the WebSocket close event\r\n//     wsRef.current.onclose = () => {\r\n//       console.log('WebSocket connection closed.');\r\n//     };\r\n\r\n//     // Event listener for the video \"play\" event\r\n//     videoRef.current.addEventListener('play', handleVideoPlay);\r\n//   };\r\n\r\n//   const handleStop = () => {\r\n//     // Close the WebSocket connection\r\n//     wsRef.current.close();\r\n\r\n//     // Remove the event listener for the video \"play\" event\r\n//     videoRef.current.removeEventListener('play', handleVideoPlay);\r\n//   };\r\n\r\n//   const handleVideoPlay = () => {\r\n//     // Create a canvas element to capture video frames\r\n//     const canvas = document.createElement('canvas');\r\n//     const ctx = canvas.getContext('2d');\r\n\r\n//     const captureFrame = () => {\r\n//       if (videoRef.current.paused || videoRef.current.ended) {\r\n//         return;\r\n//       }\r\n\r\n//       // Draw the current video frame on the canvas\r\n//       ctx.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);\r\n\r\n//       // Get the image data from the canvas\r\n//       const imageData = canvas.toDataURL('image/jpeg');\r\n\r\n//       // Send the image data as a WebSocket message to the server\r\n//       wsRef.current.send(imageData);\r\n\r\n//       // Capture the next video frame\r\n//       requestAnimationFrame(captureFrame);\r\n//     };\r\n\r\n//     // Start capturing video frames\r\n//     requestAnimationFrame(captureFrame);\r\n//   };\r\n\r\n//   return (\r\n//     <div>\r\n//       <video ref={videoRef} width=\"320\" height=\"240\" controls>\r\n//         <source src=\"path/to/video.mp4\" type=\"video/mp4\" />\r\n//       </video>\r\n//       <button onClick={handleStart}>Start</button>\r\n//       <button onClick={handleStop}>Stop</button>\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default VideoBlob;\r\n// /////////////////////\r\n// import React, { useEffect, useRef, useState } from 'react';\r\n\r\n// const VideoBlob = () => {\r\n//   const videoRef = useRef(null);\r\n//   const assetURL = 'http://localhost:3000/videos/sample.mp4';\r\n//   const mimeCodec = 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"';\r\n//   const [isLoading, setIsLoading] = useState(true);\r\n//   const [error, setError] = useState(null);\r\n\r\n//   useEffect(() => {\r\n//     let mediaSource;\r\n//     let sourceBuffer;\r\n\r\n//     const fetchAB = async (url) => {\r\n//       try {\r\n//         const response = await fetch(url);\r\n//         const buffer = await response.arrayBuffer();\r\n//         return buffer;\r\n//       } catch (error) {\r\n//         throw new Error('Error fetching video: ' + error.message);\r\n//       }\r\n//     };\r\n\r\n//     const initializeMediaSource = async () => {\r\n//       try {\r\n//         if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {\r\n//           mediaSource = new MediaSource();\r\n//           videoRef.current.src = URL.createObjectURL(mediaSource);\r\n//           mediaSource.addEventListener('sourceopen', handleSourceOpen);\r\n//         } else {\r\n//           throw new Error('Unsupported MIME type or codec: ' + mimeCodec);\r\n//         }\r\n//       } catch (error) {\r\n//         setError(error.message);\r\n//       }\r\n//     };\r\n\r\n//     const handleSourceOpen = async () => {\r\n//       try {\r\n//         sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\r\n//         sourceBuffer.addEventListener('updateend', handleUpdateEnd);\r\n//         await appendVideoChunks(assetURL, sourceBuffer);\r\n//       } catch (error) {\r\n//         setError('Error initializing source buffer: ' + error.message);\r\n//       }\r\n//     };\r\n\r\n//     const appendVideoChunks = async (url, sourceBuffer) => {\r\n//       try {\r\n//         const buffer = await fetchAB(url);\r\n//         sourceBuffer.appendBuffer(buffer);\r\n//       } catch (error) {\r\n//         setError('Error appending video chunk: ' + error.message);\r\n//       }\r\n//     };\r\n\r\n//     initializeMediaSource();\r\n\r\n//     return () => {\r\n//       if (sourceBuffer) {\r\n//         sourceBuffer.removeEventListener('updateend', handleUpdateEnd);\r\n//       }\r\n//       if (mediaSource) {\r\n//         mediaSource.removeEventListener('sourceopen', handleSourceOpen);\r\n//         mediaSource = null;\r\n//       }\r\n//     };\r\n//   }, []);\r\n\r\n//   const handleUpdateEnd = () => {\r\n//     setIsLoading(false);\r\n//     videoRef.current.play().catch((error) => {\r\n//       setError('Error playing video: ' + error.message);\r\n//     });\r\n//   };\r\n\r\n//   return (\r\n//     <div>\r\n//       {isLoading && <div>Loading...</div>}\r\n//       {error && <div>Error: {error}</div>}\r\n//       <video ref={videoRef} controls></video>\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default VideoBlob;\r\n\r\n\r\n// App.js chunks are coming frm server but problem is here\r\n// import React, { useEffect, useRef } from \"react\";\r\n\r\n// function VideoBlob() {\r\n//   const videoRef = useRef(null);\r\n//   const wsRef = useRef(null);\r\n//   const receivedChunks = useRef([]);\r\n//   const totalBytesReceived = useRef(0);\r\n\r\n//   useEffect(() => {\r\n//     wsRef.current = new WebSocket(\"ws://localhost:8000\");\r\n\r\n//     wsRef.current.onmessage = (event) => {\r\n//       const videoChunk = event.data;\r\n//       receivedChunks.current.push(videoChunk);\r\n//       totalBytesReceived.current += videoChunk.length;\r\n\r\n//       // Check if all chunks are received (e.g., by comparing total received bytes with expected size)\r\n//       // If all chunks are received, proceed to create and play the video\r\n\r\n    \r\n//         const concatenatedChunks = new Uint8Array(totalBytesReceived.current);\r\n//         let offset = 0;\r\n//         for (const chunk of receivedChunks.current) {\r\n//           concatenatedChunks.set(chunk, offset);\r\n//           offset += chunk.length;\r\n//         }\r\n\r\n//         // Create a Blob from the concatenated chunks\r\n//         const videoBlob = new Blob([concatenatedChunks], { type: \"video/mp4\" });\r\n\r\n//         // Create a Blob URL\r\n//         const videoUrl = URL.createObjectURL(videoBlob);\r\n\r\n//         // Set the video element's src attribute to the Blob URL\r\n//         videoRef.current.src = videoUrl;\r\n      \r\n//     };\r\n\r\n//     return () => {\r\n//       wsRef.current.close();\r\n//     };\r\n//   }, []);\r\n\r\n//   return (\r\n//     <div>\r\n//       <video ref={videoRef} controls />\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default VideoBlob;\r\n\r\n\r\n// //////////////////dane przychodza ale nie odtwarza video\r\n// import React, { useEffect, useRef } from \"react\";\r\n\r\n// function VideoBlob() {\r\n//   const videoRef = useRef(null);\r\n//   const wsRef = useRef(null);\r\n//   const mediaSourceRef = useRef(null);\r\n//   const sourceBufferRef = useRef(null);\r\n//   const bufferQueueRef = useRef([]);\r\n//   const isAppendingRef = useRef(false);\r\n//   const isSourceOpenRef = useRef(false);\r\n\r\n//   useEffect(() => {\r\n//     wsRef.current = new WebSocket(\"ws://localhost:8000\");\r\n\r\n//     wsRef.current.onmessage = (event) => {\r\n//       console.log(event)\r\n//       if (typeof event.data === \"string\") {\r\n//         console.log(\"string\")\r\n//         const message = JSON.parse(event.data);\r\n\r\n//         if (message.type === \"metadata\") {\r\n//           console.log(\"metadata\")\r\n//           const mediaSource = new MediaSource();\r\n//           videoRef.current.src = URL.createObjectURL(mediaSource);\r\n//           mediaSourceRef.current = mediaSource;\r\n\r\n//           mediaSource.addEventListener(\"sourceopen\", handleSourceOpen);\r\n//           mediaSource.addEventListener(\"sourceended\", handleSourceEnded);\r\n//           mediaSource.addEventListener(\"error\", handleSourceError);\r\n//         }\r\n//       } else if (event.data instanceof Blob && sourceBufferRef.current) {\r\n//         console.log(\"third\")\r\n//         const videoData = event.data;\r\n//         bufferQueueRef.current.push(videoData);\r\n\r\n//         processBufferQueue();\r\n//       }\r\n//     };\r\n\r\n//     return () => {\r\n//       wsRef.current.close();\r\n//     };\r\n//   }, []);\r\n\r\n//   const handleSourceOpen = () => {\r\n//     const mediaSource = mediaSourceRef.current;\r\n//     const sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"');\r\n//     sourceBufferRef.current = sourceBuffer;\r\n//     isSourceOpenRef.current = true;\r\n\r\n//     sourceBuffer.addEventListener(\"updateend\", processBufferQueue);\r\n//   };\r\n\r\n//   const handleSourceEnded = () => {\r\n//     console.log(\"MediaSource ended\");\r\n//   };\r\n\r\n//   const handleSourceError = (error) => {\r\n//     console.error(\"MediaSource error:\", error);\r\n//   };\r\n//   const processBufferQueue = async () => {\r\n//     if (isSourceOpenRef.current && !isAppendingRef.current && bufferQueueRef.current.length > 0) {\r\n//       const videoData = bufferQueueRef.current.shift();\r\n//       isAppendingRef.current = true;\r\n  \r\n//       try {\r\n//         const response = await fetch(URL.createObjectURL(videoData));\r\n//         const arrayBuffer = await response.arrayBuffer();\r\n//         sourceBufferRef.current.appendBuffer(arrayBuffer);\r\n//       } catch (error) {\r\n//         console.error(\"Error appending video data to SourceBuffer:\", error);\r\n//         isAppendingRef.current = false;\r\n//         processBufferQueue();\r\n//       }\r\n//     }\r\n//   };\r\n  \r\n//   return (\r\n//     <div>\r\n//       <video ref={videoRef} controls />\r\n//     </div>\r\n//   );\r\n// }\r\n// export default VideoBlob;\r\n// /////////////17.07\r\n// import React, { useEffect, useRef } from \"react\";\r\n\r\n// const VideoPlayer = () => {\r\n//   const videoRef = useRef(null);\r\n//   const websocketRef = useRef(null);\r\n\r\n//   useEffect(() => {\r\n//     // Create a WebSocket connection\r\n//     const socket = new WebSocket(\"ws://localhost:8000\");\r\n\r\n//     socket.onopen = () => {\r\n//       console.log(\"Connected to server\");\r\n//     };\r\n\r\n//     socket.onmessage = (event) => {\r\n//       // Receive video data from the server\r\n//       const data = event.data;\r\n//       videoRef.current.src = URL.createObjectURL(data);\r\n//     };\r\n\r\n//     socket.onclose = () => {\r\n//       console.log(\"Disconnected from server\");\r\n//     };\r\n\r\n//     websocketRef.current = socket;\r\n\r\n//     return () => {\r\n//       // Clean up the WebSocket connection\r\n//       websocketRef.current.close();\r\n//     };\r\n//   }, []);\r\n\r\n//   return (\r\n//     <div>\r\n//       <video ref={videoRef} controls autoPlay />\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default VideoPlayer;\r\nimport React, { useEffect, useRef, useCallback } from \"react\";\r\n\r\nconst VideoPlayer = () => {\r\n  const videoRef = useRef(null);\r\n  const mediaSourceRef = useRef(null);\r\n  const sourceBufferRef = useRef(null);\r\n  const websocketRef = useRef(null);\r\n  const queueRef = useRef([]);\r\n\r\n  const handleSourceOpen = useCallback(() => {\r\n    sourceBufferRef.current = mediaSourceRef.current.addSourceBuffer(\"video/mp4; codecs=\\\"avc1.4D401E, mp4a.40.2\\\"\");\r\n    sourceBufferRef.current.addEventListener(\"updateend\", handleUpdateEnd);\r\n  }, []);\r\n\r\n  const handleUpdateEnd = useCallback(() => {\r\n    if (queueRef.current.length > 0) {\r\n      const blob = queueRef.current.shift();\r\n      appendToSourceBuffer(blob);\r\n    }\r\n  }, []);\r\n\r\n  const appendToSourceBuffer = useCallback((blob) => {\r\n    if (sourceBufferRef.current) {\r\n      const reader = new FileReader();\r\n      reader.onload = function () {\r\n        const arrayBuffer = reader.result;\r\n        const uint8Array = new Uint8Array(arrayBuffer);\r\n        sourceBufferRef.current.appendBuffer(uint8Array);\r\n      };\r\n      reader.readAsArrayBuffer(blob);\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (!websocketRef.current) {\r\n      const socket = new WebSocket(\"ws://localhost:8000\");\r\n\r\n      socket.onopen = () => {\r\n        console.log(\"Connected to server\");\r\n      };\r\n\r\n      socket.onmessage = (event) => {\r\n        const blob = event.data;\r\n        if (!mediaSourceRef.current) {\r\n          mediaSourceRef.current = new MediaSource();\r\n          videoRef.current.src = URL.createObjectURL(mediaSourceRef.current);\r\n          console.log(videoRef.current.src);\r\n          mediaSourceRef.current.addEventListener(\"sourceopen\", handleSourceOpen);\r\n        }\r\n\r\n        if (sourceBufferRef.current && !sourceBufferRef.current.updating && queueRef.current.length === 0) {\r\n          console.log(\"blob\");\r\n          appendToSourceBuffer(blob);\r\n        } else {\r\n          queueRef.current.push(blob);\r\n          console.log(\"queue\")\r\n        }\r\n      };\r\n\r\n      socket.onclose = () => {\r\n        console.log(\"Disconnected from server\");\r\n      };\r\n\r\n      websocketRef.current = socket;\r\n    }\r\n\r\n    return () => {\r\n      if (websocketRef.current) {\r\n        websocketRef.current.close();\r\n      }\r\n    };\r\n  }, [handleSourceOpen, appendToSourceBuffer]);\r\n\r\n  return (\r\n    <div>\r\n      <video ref={videoRef} controls autoPlay />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default VideoPlayer;\r\n\r\n\r\n// Random ints working///////////////////////////////////\r\n// import React, { useState, useEffect } from 'react';\r\n\r\n// const VideoBlob = () => {\r\n//   const [currentData, setCurrentData] = useState([]);\r\n\r\n//   useEffect(() => {\r\n//     const ws = new WebSocket(\"ws://localhost:8888/\");\r\n\r\n//     ws.onopen = () => {\r\n//       console.log('Opened Connection!');\r\n//     };\r\n\r\n//     ws.onmessage = (event) => {\r\n//       setCurrentData(JSON.parse(event.data));\r\n//     };\r\n\r\n//     ws.onclose = () => {\r\n//       console.log('Closed Connection!');\r\n//     };\r\n\r\n//     return () => {\r\n//       ws.close();\r\n//     };\r\n//   }, []);\r\n\r\n\r\n\r\n//   console.log(currentData);\r\n\r\n//   return (\r\n//     <div>\r\n//       {currentData.map((cd)=>(\r\n//         <div>\r\n//           <p>{cd.name}</p>\r\n//           <p>{cd.number}</p>\r\n//         </div>\r\n//       ))}\r\n        \r\n        \r\n    \r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default VideoBlob;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// PING_PONG////////////////////////////////////////////////\r\n// import React, { useEffect, useRef } from 'react';\r\n\r\n// function VideoBlob() {\r\n//   const socketRef = useRef(null);\r\n\r\n//   useEffect(() => {\r\n//     // Create a WebSocket connection\r\n//     socketRef.current = new WebSocket('ws://localhost:8000');\r\n\r\n//     // Listen for messages from the server\r\n//     socketRef.current.onmessage = function (event) {\r\n//       console.log('Received: ', event.data);\r\n//     };\r\n\r\n//     // Clean up the WebSocket connection when the component is unmounted\r\n//     return () => {\r\n//       socketRef.current.close();\r\n//     };\r\n//   }, []);\r\n\r\n//   const sendPing = () => {\r\n//     if (socketRef.current.readyState === WebSocket.OPEN) {\r\n//       // Send a ping message to the server\r\n//       socketRef.current.send('ping');\r\n//     }\r\n//   };\r\n\r\n//   return (\r\n//     <div className=\"App\">\r\n//       <button onClick={sendPing}>Send Ping</button>\r\n//     </div>\r\n//   );\r\n// }\r\n\r\n// export default VideoBlob;\r\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AAC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"},"metadata":{},"sourceType":"module","externalDependencies":[]}